// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const completeExecution = `-- name: CompleteExecution :exec
update executions
set status = $2,
    stdout = $3,
    stderr = $4,
    execution_time_ms = $5
where id = $1
`

type CompleteExecutionParams struct {
	ID              uuid.UUID
	Status          ExecutionStatus
	Stdout          pgtype.Text
	Stderr          pgtype.Text
	ExecutionTimeMs pgtype.Int2
}

func (q *Queries) CompleteExecution(ctx context.Context, arg CompleteExecutionParams) error {
	_, err := q.db.Exec(ctx, completeExecution,
		arg.ID,
		arg.Status,
		arg.Stdout,
		arg.Stderr,
		arg.ExecutionTimeMs,
	)
	return err
}

const createCodeSession = `-- name: CreateCodeSession :one
insert into code_sessions (language, source_code)
values ($1, $2)
returning id, status, language, source_code
`

type CreateCodeSessionParams struct {
	Language   Language
	SourceCode string
}

func (q *Queries) CreateCodeSession(ctx context.Context, arg CreateCodeSessionParams) (CodeSession, error) {
	row := q.db.QueryRow(ctx, createCodeSession, arg.Language, arg.SourceCode)
	var i CodeSession
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Language,
		&i.SourceCode,
	)
	return i, err
}

const createExecution = `-- name: CreateExecution :one
insert into executions (status)
values ($1)
returning id, status
`

type CreateExecutionRow struct {
	ID     uuid.UUID
	Status ExecutionStatus
}

func (q *Queries) CreateExecution(ctx context.Context, status ExecutionStatus) (CreateExecutionRow, error) {
	row := q.db.QueryRow(ctx, createExecution, status)
	var i CreateExecutionRow
	err := row.Scan(&i.ID, &i.Status)
	return i, err
}

const getCodeSession = `-- name: GetCodeSession :one
select id, status, language, source_code from code_sessions
where id = $1
`

func (q *Queries) GetCodeSession(ctx context.Context, id uuid.UUID) (CodeSession, error) {
	row := q.db.QueryRow(ctx, getCodeSession, id)
	var i CodeSession
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Language,
		&i.SourceCode,
	)
	return i, err
}

const getExecution = `-- name: GetExecution :one
select id, status, stdout, stderr, execution_time_ms from executions
where id = $1
`

func (q *Queries) GetExecution(ctx context.Context, id uuid.UUID) (Execution, error) {
	row := q.db.QueryRow(ctx, getExecution, id)
	var i Execution
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Stdout,
		&i.Stderr,
		&i.ExecutionTimeMs,
	)
	return i, err
}

const updateCodeSession = `-- name: UpdateCodeSession :one
update code_sessions
set language = $2,
    source_code = $3
where id = $1
returning id, status, language, source_code
`

type UpdateCodeSessionParams struct {
	ID         uuid.UUID
	Language   Language
	SourceCode string
}

func (q *Queries) UpdateCodeSession(ctx context.Context, arg UpdateCodeSessionParams) (CodeSession, error) {
	row := q.db.QueryRow(ctx, updateCodeSession, arg.ID, arg.Language, arg.SourceCode)
	var i CodeSession
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Language,
		&i.SourceCode,
	)
	return i, err
}

const updateExecution = `-- name: UpdateExecution :exec
update executions
set status = $2
where id = $1
`

type UpdateExecutionParams struct {
	ID     uuid.UUID
	Status ExecutionStatus
}

func (q *Queries) UpdateExecution(ctx context.Context, arg UpdateExecutionParams) error {
	_, err := q.db.Exec(ctx, updateExecution, arg.ID, arg.Status)
	return err
}
